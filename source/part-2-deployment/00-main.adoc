= Déploiement

On va déjà parler de déploiement. Le serveur que django met à notre disposition est prévu uniquement pour le développement: inutile de passer par du code Python pour charger des fichiers statiques (feuilles de style, fichiers JavaScript, images, ...). De même, la base de donnée doit supporter plus qu'un seul utilisateur: SQLite fonctionne très bien dès lors qu'on se limite à un seul utilisateur... Sur une application Web, il est plus que probable que vous rencontriez rapidement des erreurs de base de données verrouillée pour écriture par un autre processus. Il est donc plus que bénéfique de passer sur quelque chose de plus solide. https://docs.djangoproject.com/fr/3.0/howto/deployment/[Déploiement].

Si vous avez suivi les étapes jusqu'ici, vous devriez à peine disposer d'un espace de travail proprement configuré, d'un modèle relativement basique et d'une configuration avec une base de données simpliste. En bref, vous avez quelque chose qui fonctionne, mais qui ressemble de très loin à ce que vous souhaitez au final.

Il y a une raison très simple à aborder le déploiement dès maintenant: à trop attendre et à peaufiner son développement en local, on en oublie que sa finalité sera de se retrouver exposé sur un serveur. On risque d'avoir oublié une partie des désidérata, d'avoir zappé une fonctionnalité essentielle ou simplement de passer énormément de temps à adapter les sources pour qu'elles fonctionnent sur un environnement en particulier.

Aborder le déploiement maintenant permet également de rédiger dès le début les procédures d'installation, de mise à jour et de sauvegardes. Déploier une nouvelle version sera aussi simple que de récupérer la dernière archive depuis le dépôt, la placer dans le bon répertoire, appliquer des actions spécifiques (et souvent identiques entre deux versions), puis redémarrer les services adéquats.

Dans cette partie, on abordera les points suivants:

* La définition de l'infrastructure nécessaire à notre application
* La configuration de l'hôte, qui hébergera l'application: dans une machine physique, virtuelle ou dans un container. On abordera aussi rapidement les déploiements via Ansible, Chef, Puppet ou Salt.
* Les différentes méthodes de supervision de l'application: comment analyser les fichiers de logs et comment intercepter correctement une erreur si elle se présente et comment remonter l'information.
* Une partie sur la sécurité et la sécurisation de l'hôte.

Si on schématise l'infrastructure et le chemin parcouru par une éventuelle requête, on devrait arriver à quelque chose de synthéthique:

* Au niveau de l'infrastructure, 
    . l'utilisateur fait une requête via son navigateur (Firefox ou Chrome) 
    . le navigateur envoie une requête http, sa version, un verbe (GET, POST, ...), un port et éventuellement du contenu
    . le firewall du serveur (Debian GNU/Linux, CentOS, ...) vérifie si la requête peut être prise en compte 
    . la requête est transmise à l'application qui écoute sur le port (probablement 80 ou 443; et _a priori_ Nginx)
    . elle est ensuite transmise par socket et est prise en compte par Gunicorn
    . qui la transmet ensuite à l'un de ses _workers_ (= un processus Python)
    . après exécution, une réponse est renvoyée à l'utilisateur. 

image::images/diagrams/architecture.png[]

* Au niveau logiciel (la partie mise en subrillance ci-dessus), la requête arrive dans les mains du processus Python, qui doit encore 
    . effectuer le routage des données, 
    . trouver la bonne fonction à exécuter, 
    . récupérer les données depuis la base de données, 
    . effectuer le rendu ou la conversion des données, 
    . et renvoyer une réponse à l'utilisateur.

image::images/diagrams/django-process.png[]

== Définition de l'infrastructure

Comme on l'a vu dans la première partie, Django est un framework complet, intégrant tous les mécanismes nécessaires à la bonne évolution d'une application. On peut ainsi commencer petit, et suivre l'évolution des besoins en fonction de la charge estimée ou ressentie, ajouter un mécanisme de mise en cache, des logiciels de suivi, ...

Pour une mise ne production, le standard *de facto* est le suivant:

 * Nginx comme reverse proxy
 * Gunicorn ou Uvicorn comme serveur d'application
 * Supervisorctl pour le monitoring
 * PostgreSQL ou MariaDB comme base de données.
 * Redis / Memcache pour la mise à en cache (et pour les sessions ? A vérifier).

En mode _containers_, on passera plutôt par Docker et Traefik.
 
C'est celle-ci que nous allons décrire ci-dessous.

=== Configuration et sécurisation de la machine hôte

Supervisor, nginx, gunicorn, utilisateurs, groupes, ...

[plantuml]
--
entity Nginx
entity "Gunicorn (sockets/HTTP)" as gunicorn
database PGSQL
--

Aussi : Docker, Heroku, Digital Ocean, Scaleway, OVH, Ansible, Puppet, Chef, ... Bref, sur Debian et CentOS pour avoir un panel assez large. On oublie Windows: rien que Gunicorn et Nginx n'y tournent pas.


=== Mise à jour

Script de mise à jour.

[source,bash]
----
su - <user>
source ~/.venvs/<app>/bin/activate
cd ~/webapps/<app>
git fetch 
git checkout vX.Y.Z
pip install -U requirements/prod.txt
python manage.py migrate
python manage.py collectstatic
gunicorn reload -HUP
----

WARNING: le serveur de déploiement ne doit avoir qu'un accès en lecture au dépôt source.

=== Supervision

Qu'est-ce qu'on fait des logs après ? :-)

. Sentry
. Nagios
. LibreNMS
. Zabbix

include::infrastructure.adoc[]

include::database.adoc[]

include::centos+debian.adoc[]

== Ressources
  
https://zestedesavoir.com/tutoriels/2213/deployer-une-application-django-en-production/