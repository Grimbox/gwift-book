= Déploiement


Nous sommes encore au début du projet mais abordons dès maintenant le déploiment. Il y a plusieurs raisons pour le faire.

La première est que le serveur que Django met à notre disposition n'est prévu que pour le développement : inutile de passer par du code Python pour charger des fichiers statiques (feuilles de style, fichiers JavaScript, images, ...).
Il est également probable que la base de donnée de votre application doive supporter plus d'un utilisateur.
SQLite fonctionne très bien dès lors qu'on se limite à un seul utilisateur : vous risquez de rencontrer des erreurs de base de données verrouillée pour écriture car un autre processus y accède déjà.
Il est donc nécessaire d'avoir un environnement plus solide pour la production.
https://docs.djangoproject.com/fr/3.0/howto/deployment/[Déploiement].

Une autre raison de s'intéresser au déploiment dès à présent est qu'à trop attendre et peaufiner son développement en local, sa finalité (se retrouver exposé sur un serveur) risque d'être perdue de vue.
Vous risquez d'oublier une partie des désidérata ou une fonctionnalité essentielle, de passer énormément de temps à adapter les sources pour qu'elles fonctionnent sur un environnement en particulier.

Aborder le déploiement très tôt permet également de rédiger dès le début les procédures d'installation, de mise à jour et de sauvegardes.
Déployer une nouvelle version sera aussi simple que de récupérer la dernière archive depuis le dépôt, la placer dans le bon répertoire, appliquer des actions spécifiques (et souvent identiques entre deux versions), puis redémarrer les services adéquats.

Dans cette partie, les points suivants serons abordés :

* La définition de l'infrastructure nécessaire à notre application.
* La configuration de l'hôte, qui hébergera l'application : dans une machine physique, virtuelle ou un container. On abordera aussi rapidement les déploiements via Ansible, Chef, Puppet ou Salt.
* Les différentes méthodes de supervision de l'application : comment analyser les fichiers de logs et comment intercepter correctement une erreur si elle se présente et comment remonter l'information.
* Une partie sur la sécurité et la sécurisation de l'hôte.

=== Infrastructure
L'infrastructure et le chemin parcouru par une éventuelle requête peut être schématisé de la manière suivante :

* Au niveau de l'infrastructure, 
    . l'utilisateur fait une requête via son navigateur (Firefox, Chrome, …) 
    . le navigateur envoie une requête http, sa version, un verbe (GET, POST, ...), un port et éventuellement du contenu
    . le firewall du serveur (Debian GNU/Linux, CentOS, ...) vérifie si la requête peut être prise en compte 
    . la requête est transmise à l'application qui écoute sur le port (probablement 80 ou 443; et _a priori_ Nginx)
    . elle est ensuite transmise par socket et est prise en compte par Gunicorn
    . qui la transmet ensuite à l'un de ses _workers_ (= un processus Python)
    . après exécution, une réponse est renvoyée à l'utilisateur. 

image::images/diagrams/architecture.png[]

* Au niveau logiciel (la partie mise en subrillance ci-dessus), la requête arrive dans les mains du processus Python, qui doit encore 
    . effectuer le routage des données, 
    . trouver la bonne fonction à exécuter, 
    . récupérer les données depuis la base de données, 
    . effectuer le rendu ou la conversion des données, 
    . et renvoyer une réponse à l'utilisateur.

image::images/diagrams/django-process.png[]

==== Définition de l'infrastructure

Comme abordé dans la première partie, Django est un framework complet intégrant tous les mécanismes nécessaires à la bonne évolution d'une application.
Il est ainsi possible commencer petit et de suivre l'évolution des besoins en fonction de la charge estimée ou ressentie, d'ajouter un mécanisme de mise en cache, des logiciels de suivi, etc.

Pour une mise ne production, le standard *de facto* est le suivant :

 * _Nginx_ comme reverse proxy
 * _Gunicorn_ ou Uvicorn comme serveur d'application
 * _Supervisorctl_ pour le monitoring
 * _PostgreSQL_ ou _MariaDB_ comme base de données.
 * _Redis_ ou _Memcache_ pour la mise à en cache (et pour les sessions ? A vérifier).

En mode _containers_, nous conseillons Docker et Traefik.
 
C'est celle-ci que nous allons décrire ci-dessous.

=== Configuration et sécurisation de la machine hôte

Supervisor, nginx, gunicorn, utilisateurs, groupes, ...

[plantuml]
--
entity Nginx
entity "Gunicorn (sockets/HTTP)" as gunicorn
database PGSQL
--

Aussi : Docker, Heroku, Digital Ocean, Scaleway, OVH, Ansible, Puppet, Chef, ... Bref, sur Debian et CentOS pour avoir un panel assez large. On oublie Windows: rien que Gunicorn et Nginx n'y tournent pas.


=== Mise à jour

Script de mise à jour.

[source,bash]
----
su - <user>
source ~/.venvs/<app>/bin/activate
cd ~/webapps/<app>
git fetch 
git checkout vX.Y.Z
pip install -U requirements/prod.txt
python manage.py migrate
python manage.py collectstatic
gunicorn reload -HUP
----

WARNING: le serveur de déploiement ne doit avoir qu'un accès en lecture au dépôt source.

=== Supervision

Qu'est-ce qu'on fait des logs après ? :-)

. Sentry
. Nagios
. LibreNMS
. Zabbix

include::infrastructure.adoc[]

include::database.adoc[]

include::centos+debian.adoc[]

== Ressources
  
https://zestedesavoir.com/tutoriels/2213/deployer-une-application-django-en-production/