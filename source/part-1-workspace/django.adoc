== Django

Comme on l'a vu ci-dessus, `django-admin` permet de créer un nouveau projet. On fait ici une distinction entre un **projet** et une **application**:

 * **Projet**: ensemble des applications, paramètres, pages HTML, middlwares, dépendances, etc., qui font que votre code fait ce qu'il est sensé faire.
 * **Application**: *contexte* éventuellement indépendant, permettant d'effectuer une partie isolée de ce que l'on veut faire.

Pour `gwift`, on va notamment avoir 

. une première application pour la gestion des listes de souhaits et des éléments, 
. une deuxième application pour la gestion des utilisateurs,
. voire une troisième application qui gérera les partages entre utilisateurs et listes.

On voit bien ici le principe de **contexte**: l'application viendra avec son modèle, ses tests, ses vues et son paramétrage. Elle pourra éventuellement être réutilisée dans un autre projet. C'est en ça que consistent les https://www.djangopackages.com/[paquets Django] déjà disponibles: ce sont simplement de petites applications empaquetées pour être réutilisées (eg. https://github.com/tomchristie/django-rest-framework[Django-Rest-Framework], https://github.com/django-debug-toolbar/django-debug-toolbar[Django-Debug-Toolbar], ...).

NOTE: analyser la structure de ces paquets et comparer avec la structure finale de l'environnement.

=== Gestion

Comme expliqué un peu plus haut, le fichier `manage.py` est un *wrapper* sur les commandes `django-admin`. A partir de maintenant, nous n'utiliserons plus que celui-là pour tout ce qui touchera à la gestion de notre projet:

 * `manage.py check` pour vérifier (en surface...) que votre projet ne rencontre aucune erreur
 * `manage.py check --deploy`, pour vérifier (en surface aussi) que l'application est prête pour un déploiement.
 * `manage.py runserver` pour lancer un serveur de développement
 * `manage.py test` pour découvrir les tests unitaires disponibles et les lancer.

La liste complète peut être affichée avec `manage.py help`. Vous remarquerez que ces commandes sont groupées selon différentes catégories:

 * **auth**: création d'un nouveau super-utilisateur, changer le mot de passe pour un utilisateur existant.
 * **django**: vérifier la *compliance* du projet, lancer un *shell*, *dumper* les données de la base, effectuer une migration du schéma, ...
 * **sessions**: suppressions des sessions en cours
 * **staticfiles**: gestion des fichiers statiques et lancement du serveur de développement.

Nous verrons plus tard comment ajouter de nouvelles commandes.

=== Structure d'une application

Maintenant que l'on a vu à quoi servait `manage.py`, on peut créer notre nouvelle application grâce à la commande `manage.py startapp <label>`.

Cette application servira à structurer les listes de souhaits, les éléments qui les composent et les parties que chaque utilisateur pourra offrir. Essayez de trouver un nom éloquent, court et qui résume bien ce que fait l'application. Pour nous, ce sera donc `wish`. C'est parti pour `manage.py startapp wish`!

[source,bash]
----
$ python manage.py startapp wish
----

Résultat? Django nous a créé un répertoire `wish`, dans lequel on trouve les fichiers et dossiers suivants:

 * `wish/admin.py` servira à structurer l'administration de notre application. Chaque information peut en effet être administrée facilement au travers d'une interface générée à la volée par le framework. On y reviendra par la suite.
 * `wish/__init__.py` pour que notre répertoire `wish` soit converti en package Python.
 * `wish/migrations/`, dossier dans lequel seront stockées toutes les différentes migrations de notre application.
 * `wish/models.py` pour représenter et structurer nos données.
 * `wish/tests.py` pour les tests unitaires.

Par soucis de clarté, déplacez ce nouveau répertoire `wish` dans votre répertoire `gwift` existant. C'est une forme de convention. La structure de vos répertoires devient celle-ci:

[source,bash]
----
(gwift-env) fred@aerys:~/Sources/gwift$ tree .
.
├── docs
│   └── README.md
├── gwift
│   ├── asgi.py
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   ├── wish <1>
│   │   ├── admin.py
│   │   ├── apps.py
│   │   ├── __init__.py
│   │   ├── migrations
│   │   │   └── __init__.py
│   │   ├── models.py
│   │   ├── tests.py
│   │   └── views.py
│   └── wsgi.py
├── Makefile
├── manage.py
├── requirements
│   ├── base.txt
│   ├── dev.txt
│   └── prod.txt
├── setup.cfg
└── tox.ini

6 directories, 22 files
----
<1> Notre application a bien été créée, et on l'a déplacée dans le répertoire `gwift` !

NOTE: vérifier s'il s'agit bien d'une forme de convention :-p 

NOTE: Vérifier aussi comment les applications sont construites. Type DRF, Django Social Auth, tout ça.


