== Boite Ã  outils

=== Python

Le langage https://www.python.org/[Python] est un https://docs.python.org/3/faq/general.html#what-is-python[langage de programmation] interprÃ©tÃ©, interactif, orientÃ© objet (souvent), fonctionnel (parfois), open source, multi-plateformes, flexible, facile Ã  apprendre et difficile Ã  maÃ®triser.

.https://xkcd.com/353/
image::images/xkcd-353-python.png[]

A premiÃ¨re vue, certains concepts restent difficiles Ã  aborder: l'indentation dÃ©finit l'Ã©tendue d'un bloc (classe, fonction, mÃ©thode, boucle, condition, ...), il n'y a pas de typage fort des variables et le compilateur n'est pas lÃ  pour assurer le filet de sÃ©curitÃ© avant la mise en production (puisqu'il n'y a pas de compilateur ğŸ˜›).
Et malgrÃ© ces quelques points, Python reste un langage gÃ©nÃ©raliste accessible et "bon partout", et de pouvoir se reposer sur un Ã©cosystÃ¨me stable et fonctionnel.

Il fonctionne avec un systÃ¨me d'amÃ©liorations basÃ©es sur des propositions: les PEP, ou "**Python Enhancement Proposal**".
Chacune d'entre elles doit Ãªtre approuvÃ©e par le http://fr.wikipedia.org/wiki/Benevolent_Dictator_for_Life[Benevolent Dictator For Life].

Si vous avez besoin d'un aide-mÃ©moire ou d'une liste exhaustive des types et structures de donnÃ©es du langage, rÃ©fÃ©rez-vous au lien suivant: https://gto76.github.io/python-cheatsheet/[Python Cheat Sheet].

NOTE: Le langage Python utilise un typage dynamique appelÃ© https://fr.wikipedia.org/wiki/Duck_typing[*duck typing*]: "_When I see a bird that quacks like a duck, walks like a duck, has feathers and webbed feet and associates with ducks â€” Iâ€™m certainly going to assume that he is a duck_" (Source: http://en.wikipedia.org/wiki/Duck_test[Wikipedia (as usual)]).

==== PEP8 - Style Guide for Python Code

La premiÃ¨re PEP qui va nous intÃ©resser est la https://www.python.org/dev/peps/pep-0008/[PEP 8 -- Style Guide for Python Code]. Elle spÃ©cifie comment du code Python doit Ãªtre organisÃ© ou formatÃ©, quelles sont les conventions pour lâ€™indentation, le nommage des variables et des classes, ...
En bref, elle dÃ©crit comment Ã©crire du code proprement, afin que dâ€™autres dÃ©veloppeurs puissent le reprendre facilement, ou simplement que votre base de code ne dÃ©rive lentement vers un seuil de non-maintenabilitÃ©.

Dans cet objectif, un outil existe et listera l'ensemble des conventions qui ne sont pas correctement suivies dans votre projet: pep8. Pour l'installer, passez par pip. Lancez ensuite la commande pep8 suivie du chemin Ã  analyser (`.`, le nom d'un rÃ©pertoire, le nom d'un fichier `.py`, ...). Si vous souhaitez uniquement avoir le nombre d'erreur de chaque type, saisissez les options `--statistics -qq`.


[source,bash]
----
$ pep8 . --statistics -qq

7       E101 indentation contains mixed spaces and tabs
6       E122 continuation line missing indentation or outdented
8       E127 continuation line over-indented for visual indent
23      E128 continuation line under-indented for visual indent
3       E131 continuation line unaligned for hanging indent
12      E201 whitespace after '{'
13      E202 whitespace before '}'
86      E203 whitespace before ':'
----

Si vous ne voulez pas Ãªtre dÃ©rangÃ© sur votre maniÃ¨re de coder, et que vous voulez juste avoir un retour sur une analyse de votre code, essayez `pyflakes`: cette librairie analysera vos sources Ã  la recherche de sources d'erreurs possibles (imports inutilisÃ©s, mÃ©thodes inconnues, etc.).


==== PEP257 - Docstring Conventions

Python Ã©tant un langage interprÃ©tÃ© fortement typÃ©, il est plus que conseillÃ©, au mÃªme titre que les tests unitaires que nous verrons plus bas, de documenter son code.
Cela impose une certaine rigueur, mais amÃ©liore Ã©normÃ©ment la qualitÃ© (et la reprise) du code par une tierce personne.
Cela implique aussi de **tout** documenter: les modules, les paquets, les classes, les fonctions, mÃ©thodes, ...
Tout doit avoir un *docstring* associÃ© :-).

WARNING: Documentation: be obsessed!

Il existe plusieurs types de conventions de documentation:

. PEP 257
. Numpy
. Google Style (parfois connue sous l'intitulÃ© `Napoleon`)
. ...

Les https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings[conventions proposÃ©es par Google] nous semblent  plus faciles Ã  lire que du RestructuredText, mais sont parfois moins bien intÃ©grÃ©es que les docstrings officiellement supportÃ©es (typiquement, par exemple par https://clize.readthedocs.io/en/stable/[clize] qui ne reconnait que du RestructuredText).
L'exemple donnÃ© dans les styleguide est celui-ci:

[source,python]
----
def fetch_smalltable_rows(table_handle: smalltable.Table,
                          keys: Sequence[Union[bytes, str]],
                          require_all_keys: bool = False,
) -> Mapping[bytes, Tuple[str]]:
    """Fetches rows from a Smalltable.

    Retrieves rows pertaining to the given keys from the Table instance
    represented by table_handle.  String keys will be UTF-8 encoded.

    Args:
        table_handle: An open smalltable.Table instance.
        keys: A sequence of strings representing the key of each table
          row to fetch.  String keys will be UTF-8 encoded.
        require_all_keys: Optional; If require_all_keys is True only
          rows with values set for all keys will be returned.

    Returns:
        A dict mapping keys to the corresponding table row data
        fetched. Each row is represented as a tuple of strings. For
        example:

        {b'Serak': ('Rigel VII', 'Preparer'),
         b'Zim': ('Irk', 'Invader'),
         b'Lrrr': ('Omicron Persei 8', 'Emperor')}

        Returned keys are always bytes.  If a key from the keys argument is
        missing from the dictionary, then that row was not found in the
        table (and require_all_keys must have been False).

    Raises:
        IOError: An error occurred accessing the smalltable.
    """
----

C'est-Ã -dire:

. Une courte ligne d'introduction, descriptive, indiquant ce que la fonction ou la mÃ©thode rÃ©alise. Attention, la documentation ne doit pas indiquer _comment_ la fonction/mÃ©thode est implÃ©mentÃ©e, mais ce qu'elle fait concrÃ¨tement (et succintement).
. Une ligne vide
. Une description plus complÃ¨te et plus verbeuse
. Une ligne vide
. La description des arguments et paramÃ¨tres, des valeurs de retour (+ exemples) et les exceptions qui peuvent Ãªtre levÃ©es.

Un exemple (encore) plus complet peut Ãªtre trouvÃ© https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html#example-google[dans le dÃ©pÃ´t sphinxcontrib-napoleon].

Pour ceux que cela pourrait intÃ©resser, il existe https://marketplace.visualstudio.com/items?itemName=njpwerner.autodocstring[une extension pour Codium], comme nous le verrons juste aprÃ¨s, qui permet de gÃ©nÃ©rer automatiquement le squelette de documentation d'un bloc de code:

.autodocstring
image::images/environment/python-docstring-vscode.png[]

NOTE: Nous le verrons plus loin, Django permet de rendre la documentation immÃ©diatement accessible depuis son interface d'administration.

==== Linters

Il existe plusieurs niveaux de _linters_:

. Le premier niveau concerne https://pypi.org/project/pycodestyle/[pycodestyle] (anciennement, `pep8` justement...), qui analyse votre code Ã  la recherche d'erreurs de convention.
. Le deuxiÃ¨me niveau concerne https://pypi.org/project/pyflakes/[pyflakes]. Pyflakes est un _simple_ footnote:[Ce n'est pas moi qui le dit, c'est la doc du projet] programme qui recherchera des erreurs parmi vos fichiers Python.
. Le troisiÃ¨me niveau est https://pypi.org/project/flake8/[Flake8], qui regroupe les deux premiers niveaux, en plus d'y ajouter flexibilitÃ©, extensions et une analyse de complexitÃ© de McCabe.
. Le quatriÃ¨me niveau footnote:[Oui, en Python, il n'y a que quatre cercles Ã  l'Enfer] est https://pylint.org/[PyLint].

PyLint est le meilleur ami de votre _moi_ futur, un peu comme quand vous prenez le temps de faire la vaisselle pour ne pas avoir Ã  la faire le lendemain: il rendra votre code soyeux et brillant, en posant des affirmations spÃ©cifiques.
A vous de les traiter en corrigeant le code ou en apposant un _tag_ indiquant que vous avez pris connaissance de la remarque, que vous en avez tenu compte, et que vous choisissez malgrÃ© tout de faire autrement.

Pour vous donner une idÃ©e, voici ce que cela pourrait donner avec un code pas trÃ¨s propre et qui ne sert Ã  rien:

[source,python]
----
from datetime import datetime

"""On stocke la date du jour dans la variable ToD4y"""

ToD4y = datetime.today()

def print_today(ToD4y):
    today = ToD4y
    print(ToD4y)

def GetToday():
    return ToD4y


if __name__ == "__main__":
    t =   Get_Today()
    print(t)


----

Avec Flake8, nous obtiendrons ceci:

[source,bash]
----
test.py:7:1: E302 expected 2 blank lines, found 1
test.py:8:5: F841 local variable 'today' is assigned to but never used
test.py:11:1: E302 expected 2 blank lines, found 1
test.py:16:8: E222 multiple spaces after operator
test.py:16:11: F821 undefined name 'Get_Today'
test.py:18:1: W391 blank line at end of file
----

Nous trouvons des erreurs:

* de *conventions*: le nombre de lignes qui sÃ©parent deux fonctions, le nombre d'espace aprÃ¨s un opÃ©rateur, une ligne vide Ã  la fin du fichier, ... Ces _erreurs_ n'en sont pas vraiment, elles indiquent juste de potentiels problÃ¨mes de communication si le code devait Ãªtre lu ou compris par une autre personne.
* de *dÃ©finition*: une variable assignÃ©e mais pas utilisÃ©e ou une lexÃ¨me non trouvÃ©. Cette derniÃ¨re information indique clairement un bug potentiel. Ne pas en tenir compte nuira sans doute Ã  la santÃ© de votre code (et risque de vous rÃ©veiller Ã  cinq heures du mat', quand votre application se prendra mÃ©chamment les pieds dans le tapis).

L'Ã©tape d'aprÃ¨s consiste Ã  invoquer pylint. Lui, il est directement moins conciliant:


[source,text]
----
$ pylint test.py
************* Module test
test.py:16:6: C0326: Exactly one space required after assignment
    t =   Get_Today()
      ^ (bad-whitespace)
test.py:18:0: C0305: Trailing newlines (trailing-newlines)
test.py:1:0: C0114: Missing module docstring (missing-module-docstring)
test.py:3:0: W0105: String statement has no effect (pointless-string-statement)
test.py:5:0: C0103: Constant name "ToD4y" doesn't conform to UPPER_CASE naming style (invalid-name)
test.py:7:16: W0621: Redefining name 'ToD4y' from outer scope (line 5) (redefined-outer-name)
test.py:7:0: C0103: Argument name "ToD4y" doesn't conform to snake_case naming style (invalid-name)
test.py:7:0: C0116: Missing function or method docstring (missing-function-docstring)
test.py:8:4: W0612: Unused variable 'today' (unused-variable)
test.py:11:0: C0103: Function name "GetToday" doesn't conform to snake_case naming style (invalid-name)
test.py:11:0: C0116: Missing function or method docstring (missing-function-docstring)
test.py:16:4: C0103: Constant name "t" doesn't conform to UPPER_CASE naming style (invalid-name)
test.py:16:10: E0602: Undefined variable 'Get_Today' (undefined-variable)

--------------------------------------------------------------------
Your code has been rated at -5.45/10
----

En gros, j'ai programmÃ© comme une grosse bouse anÃ©mique (et oui, le score d'Ã©valuation du code permet bien d'aller en nÃ©gatif). En vrac, on trouve des problÃ¨mes liÃ©s:

* au nommage (C0103) et Ã  la mise en forme (C0305, C0326, W0105)
* Ã  des variables non dÃ©finies (E0602)
* de la documentation manquante (C0114, C0116)
* de la redÃ©finition de variables (W0621).


Pour reprendre la http://pylint.pycqa.org/en/latest/user_guide/message-control.html[documentation], chaque code possÃ¨de sa signification (ouf!):

* C convention related checks
* R refactoring related checks
* W various warnings
* E errors, for probable bugs in the code
* F fatal, if an error occurred which prevented pylint from doing further* processing.

TODO: Expliquer comment faire pour tagger une explication.

==== Formatage de code

Nous avons parlÃ© ci-dessous de style de codage pour Python (PEP8), de style de rÃ©daction pour la documentation (PEP257), d'un _linter_ pour nous indiquer quels morceaux de code doivent absolument Ãªtre revus, ...
Reste que ces tÃ¢ches sont [line-through]#parfois# (trÃ¨s) souvent fastidieuses: Ã©crire un code propre et systÃ©matiquement cohÃ©rent est une tÃ¢che ardue. Heureusement, il existe des outils pour nous aider (un peu).

A nouveau, il existe plusieurs possibilitÃ©s de formatage automatique du code.
MÃªme si elle n'est pas parfaite, https://black.readthedocs.io/en/stable/[Black] arrive Ã  un compromis entre la clartÃ© du code, la facilitÃ© d'installation et d'intÃ©gration et un rÃ©sultat.

Est-ce que ce formatage est idÃ©al et acceptÃ© par tout le monde ?
Non. MÃªme Pylint arrivera parfois Ã  rÃ¢ler.
Mais ce formatage conviendra dans 97,83% des cas (au moins).

> By using Black, you agree to cede control over minutiae of hand-formatting. In return, Black gives you speed, determinism, and freedom from pycodestyle nagging about formatting. You will save time and mental energy for more important matters.
>
> Black makes code review faster by producing the smallest diffs possible. Blackened code looks the same regardless of the project youâ€™re reading. Formatting becomes transparent after a while and you can focus on the content instead.

Traduit rapidement Ã  partir de la langue de Batman: "_En utilisant Black, vous cÃ©dez le contrÃ´le sur le formatage de votre code. En retour, Black vous fera gagner un max de temps, diminuera votre charge mentale et fera revenir l'Ãªtre aimÃ©_". Mais la partie rÃ©ellement intÃ©ressante concerne le fait que "_Tout code qui sera passÃ© par Black aura la mÃªme forme, indÃ©pendamment du project sur lequel vous serez en train de travailler. L'Ã©tape de formatage deviendra transparente, et vous pourrez vous concentrer sur le contenu_".


==== ComplexitÃ© cyclomatique

A nouveau, un greffon pour `flake8` existe et donnera une estimation de la complexitÃ© de McCabe pour les fonctions trop complexes. Installez-le avec `pip install mccabe`, et activez-le avec le paramÃ¨tre `--max-complexity`. Toute fonction dans la complexitÃ© est supÃ©rieure Ã  cette valeur sera considÃ©rÃ©e comme trop complexe.


==== Typage statique

-> Mypy

==== Tests unitaires

*-> PyTest*

Comme tout bon *framework* qui se respecte, Django embarque tout un environnement facilitant le lancement de tests; chaque application est crÃ©Ã©e par dÃ©faut avec un fichier **tests.py**, qui inclut la classe `TestCase` depuis le package `django.test`:

[source,python]
----
from django.test import TestCase

class TestModel(TestCase):
    def test_str(self):
        raise NotImplementedError('Not implemented yet')
----

IdÃ©alement, chaque fonction ou mÃ©thode doit Ãªtre testÃ©e afin de bien en valider le fonctionnement, indÃ©pendamment du reste des composants. Cela permet d'isoler chaque bloc de maniÃ¨re unitaire, et permet de ne pas rencontrer de rÃ©gression lors de l'ajout d'une nouvelle fonctionnalitÃ© ou de la modification d'une existante. Il existe plusieurs types de tests (intÃ©gration, comportement, ...); on ne parlera ici que des tests unitaires.

Avoir des tests, c'est bien. S'assurer que tout est testÃ©, c'est mieux. C'est lÃ  qu'il est utile d'avoir le pourcentage de code couvert par les diffÃ©rents tests, pour savoir ce qui peut Ãªtre amÃ©liorÃ©.

TODO: VÃ©rifier  comment les applications sont construites. Type DRF, Django Social Auth, tout Ã§a.


==== Couverture de code

La couverture de code est une analyse qui donne un pourcentage liÃ© Ã  la quantitÃ© de code couvert par les tests. Attention qu'il ne s'agit pas de vÃ©rifier que le code est **bien** testÃ©, mais juste de vÃ©rifier **quelle partie** du code est testÃ©e. En Python, il existe le paquet https://pypi.python.org/pypi/coverage/[coverage], qui se charge d'Ã©valuer le pourcentage de code couvert par les tests. Ajoutez-le dans le fichier `requirements/base.txt`, et lancez une couverture de code grÃ¢ce Ã  la commande `coverage`. La configuration peut se faire dans un fichier `.coveragerc` que vous placerez Ã  la racine de votre projet, et qui sera lu lors de l'exÃ©cution.

[source,bash]
----
# requirements/base.text
[...]
coverage
django_coverage_plugin
----

[source,bash]
----
# .coveragerc to control coverage.py
[run]
branch = True
omit = ../*migrations*
plugins =
    django_coverage_plugin

[report]
ignore_errors = True

[html]
directory = coverage_html_report
----


[source,bash]
----
$ coverage run --source "." manage.py test
$ coverage report

    Name                      Stmts   Miss  Cover
    ---------------------------------------------
    gwift\gwift\__init__.py       0      0   100%
    gwift\gwift\settings.py      17      0   100%
    gwift\gwift\urls.py           5      5     0%
    gwift\gwift\wsgi.py           4      4     0%
    gwift\manage.py               6      0   100%
    gwift\wish\__init__.py        0      0   100%
    gwift\wish\admin.py           1      0   100%
    gwift\wish\models.py         49     16    67%
    gwift\wish\tests.py           1      1     0%
    gwift\wish\views.py           6      6     0%
    ---------------------------------------------
    TOTAL                        89     32    64%
    ----

$ coverage html
----

Ceci vous affichera non seulement la couverture de code estimÃ©e, et gÃ©nÃ©rera Ã©galement vos fichiers sources avec les branches non couvertes.


==== Matrice de compatibilitÃ©

DÃ©crire un fichier tox.ini

[source,bash]
----
$ touch tox.ini
----


==== Configuration globale

DÃ©crire le fichier setup.cfg

[source,bash]
----
$ touch setup.cfg
----


==== Makefile

Pour gagner un peu de temps, n'hÃ©sitez pas Ã  crÃ©er un fichier `Makefile` que vous placerez Ã  la racine du projet. L'exemple ci-dessous permettra, grÃ¢ce Ã  la commande `make coverage`, d'arriver au mÃªme rÃ©sultat que ci-dessus:

[source,makefile]
----
# Makefile for gwift
#

# User-friendly check for coverage
ifeq ($(shell which coverage >/dev/null 2>&1; echo $$?), 1)
    $(error The 'coverage' command was not found. Make sure you have coverage installed)
endif

.PHONY: help coverage

help:
    @echo "  coverage to run coverage check of the source files."

coverage:
    coverage run --source='.' manage.py test; coverage report; coverage html;
    @echo "Testing of coverage in the sources finished."
----


==== The Zen of Python

[source,text]
----
>>> import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
----


=== Environnement de dÃ©veloppement

ConcrÃ¨tement, nous pourrions tout Ã  fait nous limiter Ã  Notepad ou Notepad++.
Mais Ã  moins d'aimer se fouetter avec un cÃ¢ble USB, nous apprÃ©cions la complÃ©tion du code, la coloration syntaxique, l'intÃ©gration des tests unitaires et d'un debugger, ainsi que deux-trois sucreries qui feront plaisir Ã  n'importe quel dÃ©veloppeur.

Si vous manquez d'idÃ©es ou si vous ne savez pas par oÃ¹ commencer:

* https://vscodium.com/[VSCodium], avec les plugins https://marketplace.visualstudio.com/items?itemName=ms-python.python[Python]et https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens[GitLens]
* https://www.jetbrains.com/pycharm/[PyCharm]
* https://www.vim.org/[Vim] avec les plugins https://github.com/davidhalter/jedi-vim[Jedi-Vim] et https://github.com/preservim/nerdtree[nerdtree]

Si vous hÃ©sitez, et mÃªme si Codium n'est pas le plus lÃ©ger (la faute Ã  https://www.electronjs.org/[Electron]...), il fera correctement son travail (Ã  savoir: faciliter le vÃ´tre), en intÃ©grant suffisament de fonctionnalitÃ©s qui gÃ¢teront les papilles Ã©moustillÃ©es du dÃ©veloppeur impatient.

.Codium en action
image::images/environment/codium.png[]

=== Un terminal

_A priori_, les IDE footnote:[Integrated Development Environment] proposÃ©s ci-dessus fournissent par dÃ©faut ou _via_ des greffons un terminal intÃ©grÃ©.
Ceci dit, disposer d'un terminal sÃ©parÃ© facilite parfois certaines tÃ¢ches.

A nouveau, si vous manquez d'idÃ©es:

. Si vous Ãªtes sous Windows, tÃ©lÃ©chargez une copie de https://cmder.net/[Cmder]. Il n'est pas le plus rapide, mais propose une intÃ©gration des outils Unix communs (`ls`, `pwd`, `grep`, `ssh`, `git`, ...) sans trop se fouler.
. Pour tout autre systÃ¨me, vous devriez disposer en natif de ce qu'il faut.

.Mise en abÃ®me
image::images/environment/terminal.png[]

=== Un gestionnaire de base de donnÃ©es

Django gÃ¨re plusieurs moteurs de base de donnÃ©es.
Certains sont gÃ©rÃ©s nativement par Django (PostgreSQL, MariaDB, SQLite); _a priori_, ces trois-lÃ  sont disponibles pour tous les systÃ¨mes d'exploitation. D'autres moteurs nÃ©cessitent des librairies tierces (Oracle, Microsoft SQL Server).

Il n'est pas obligatoire de disposer d'une application de gestion pour ces moteurs: pour les cas d'utilisation simples, le shell Django pourra largement suffire (nous y reviendrons).
Mais pour faciliter la gestion des bases de donnÃ©es elles-mÃªme, et si vous n'Ãªtes pas Ã  l'aise avec la ligne de commande, choisissez l'une des applications d'administration ci-dessous en fonction du moteur de base de donnÃ©es que vous souhaitez utiliser.

* Pour *PostgreSQL*, il existe https://www.pgadmin.org/[pgAdmin]
* Pour *MariaDB* ou *MySQL*, partez sur https://www.phpmyadmin.net/[PHPMyAdmin]
* Pour *SQLite*, il existe https://sqlitebrowser.org/[SQLiteBrowser]
PHPMyAdmin ou PgAdmin.


=== Un gestionnaire de mots de passe

Nous en auront besoin pour gÃ©(nÃ©)rer des phrases secrÃ¨tes pour nos applications.
Si vous n'en utilisez pas dÃ©jÃ  un, partez sur https://keepassxc.org/[KeepassXC]: il est multi-plateformes, suivi et s'intÃ¨gre correctement aux diffÃ©rents environnements, tout en restant accessible.

image::images/environment/keepass.png[]


=== Un systÃ¨me de gestion de versions

Il existe plusieurs systÃ¨mes de gestion de versions.
Le plus connu Ã  l'heure actuelle est https://git-scm.com/[Git], notamment pour sa (trÃ¨s) grande flexibilitÃ© et sa rapiditÃ© d'exÃ©cution.
Il est une aide prÃ©cieuse pour dÃ©velopper rapidement des preuves de concept, switcher vers une nouvelle fonctionnalitÃ©, un bogue Ã  rÃ©parer ou une nouvelle release Ã  proposer au tÃ©lÃ©chargement.
Ses deux plus gros dÃ©fauts concerneraient peut-Ãªtre sa courbe d'apprentissage pour les nouveaux venus et la complexitÃ© des actions qu'il permet de rÃ©aliser.

.https://xkcd.com/1597/
image::images/xkcd-1597-git.png[]

MÃªme pour un dÃ©veloppeur solitaire, un systÃ¨me de gestion de versions (quel qu'il soit) reste indispensable.

Chaque "*branche*" correspond Ã  une tÃ¢che Ã  rÃ©aliser: un bogue Ã  corriger (_Hotfix A_), une nouvelle fonctionnalitÃ© Ã  ajouter ou un "_truc Ã  essayer_" footnote:[Oui, comme dans "Attends, j'essaie vite un truc, si Ã§a marche, c'est beau."] (_Feature A_ et _Feature B_).
Chaque "*commit*" correspond Ã  une sauvegarde atomique d'un Ã©tat ou d'un ensemble de modifications cohÃ©rentes entre elles.footnote:[Il convient donc de s'abstenir de modifier le CSS d'une application et la couche d'accÃ¨s Ã  la base de donnÃ©es, sous peine de se faire huer par ses relecteurs au prochain stand-up.]
De cette maniÃ¨re, il est beaucoup plus facile pour le dÃ©veloppeur de se concenter sur un sujet en particulier, dans la mesure oÃ¹ celui-ci ne doit pas obligatoirement Ãªtre clÃ´turÃ© pour appliquer un changement de contexte.

.Git en action
image::images/diagrams/git-workflow.png[]

Cas pratique: vous dÃ©veloppez cette nouvelle fonctionnalitÃ© qui va rÃ©volutionner le monde de demain et d'aprÃ¨s-demain, quand, tout Ã  coup (!), vous vous rendez compte que vous avez perdu votre conformitÃ© aux normes PCI parce les donnÃ©es des titulaires de cartes ne sont pas isolÃ©es correctement.
Il suffit alors de:

. sauver le travail en cours (`git add . && git commit -m [WIP]`)
. revenir sur la branche principale (`git checkout main`)
. crÃ©er un "hotfix" (`git checkout -b hotfix/pci-compliance`)
. solutionner le problÃ¨me (sans doute un `;` en trop ?)
. sauver le correctif sur cette branche (`git add . && git commit -m "Did it!"`)
. rÃ©cupÃ©rer ce correctif sur la branche principal (`git checkout main && git merge hotfix/pci-compliance`)
. et revenir tranquillou sur votre branche de dÃ©veloppement pour fignoler ce gÃ©nÃ©rateur de noms de dinosaures rigolos que l'univers vous rÃ©clame Ã  cor et Ã  a cri (`git checkout features/dinolol`)

Finalement, sachez qu'il existe plusieurs maniÃ¨res de gÃ©rer ces flux d'informations.
Les plus connus sont https://www.gitflow.com/[Gitflow] et https://www.reddit.com/r/programming/comments/7mfxo6/a_branching_strategy_simpler_than_gitflow/[Threeflow].

=== DÃ©crire ses changements

-> parler de la bonne structure d'un commit.
