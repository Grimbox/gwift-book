== Un projet Django


=== Travailler en isolation

Nous allons aborder la gestion et l'isolation des dÃ©pendances.
Cette section est aussi utile pour une personne travaillant seule, que pour transmettre les connaissances Ã  un nouveau membre de l'Ã©quipe ou pour dÃ©ployer l'application elle-mÃªme.

Il en Ã©tait dÃ©jÃ  question au deuxiÃ¨me point des 12 facteurs: mÃªme dans le cas de petits projets, il est dÃ©conseillÃ© de s'en passer.
Cela Ã©vite les dÃ©ploiements effectuÃ©s Ã  l'arrache Ã  grand renfort de `sudo` et d'installation globale de dÃ©pendances, pouvant potentiellement occasioner des conflits entre les applications dÃ©ployÃ©es:

. Il est tout Ã  fait envisagable que deux applications diffÃ©rentes soient dÃ©ployÃ©es sur un mÃªme hÃ´te, et nÃ©cessitent chacune deux versions diffÃ©rentes d'une mÃªme dÃ©pendance.
. Pour la reproductibilitÃ© d'un environnement spÃ©cifique, cela Ã©vite notamment les rÃ©ponses type "Ca juste marche chez moi", puisque la construction d'un nouvel environnement fait partie intÃ©grante du processus de construction et de la documentation du projet; grÃ¢ce Ã  elle, nous avons la possibilitÃ© de construire un environnement sain et d'appliquer des dÃ©pendances identiques, quelle que soit la machine hÃ´te.

image::images/it-works-on-my-machine.jpg[]


Dans la suite de ce chapitre, nous allons considÃ©rer deux projets diffÃ©rents:

. Gwift, une application permettant de gÃ©rer des listes de souhaits
. Khana, une application de suivi d'apprentissage pour des Ã©lÃ¨ves ou Ã©tudiants.

==== Environnement virtuel

Depuis la version 3.5 de Python, le module `venv` est https://docs.python.org/3/library/venv.html[la maniÃ¨re recommandÃ©e] pour crÃ©er un environnement virtuel.

NOTE: Il existe plusieurs autres modules permettant d'arriver au mÃªme rÃ©sultat, avec quelques avantages et inconvÃ©nients pour chacun d'entre eux. Le plus prometteur d'entre eux est https://python-poetry.org/[Poetry], qui dispose d'une interface en ligne de commande plus propre et plus moderne que ce que PIP propose.

Pour crÃ©er un nouvel environnement, vous aurez donc besoin:

. D'une installation de Python - https://www.python.org/
. D'un terminal - voir le point <<../environment/_index.adoc#un-terminal,Un terminal>>


NOTE: J'ai pour habitude de conserver mes projets dans un rÃ©pertoire `~/Sources/` et mes environnements virtuels dans un rÃ©pertoire `~/.venvs/`.
Cette sÃ©paration Ã©vite que l'environnement virtuel ne se trouve dans le mÃªme rÃ©pertoire que les sources, ou ne soit accidentellement envoyÃ© vers le systÃ¨me de gestion de versions.
Dans la suite de ce chapitre, je considÃ©rerai ces mÃªmes rÃ©pertoires, mais n'hÃ©sitez pas Ã  les modifier.

Pur crÃ©er notre rÃ©pertoire de travail et notre environnement virtuel, exÃ©cutez les commandes suivantes:

[source,bash]
----
mkdir ~/.venvs/
python -m venv ~/.venvs/gwift-venv
----

Ceci aura pour effet de crÃ©er un nouveau rÃ©pertoire (`~/.venvs/gwift-env/`), dans lequel vous trouverez une installation complÃ¨te de l'interprÃ©teur Python.
Votre environnement virtuel est prÃªt, il n'y a plus qu'Ã  indiquer que nous souhaitons l'utiliser, grÃ¢ce Ã  l'une des commandes suivantes:

[source,bash]
----
# GNU/Linux, macOS
source ~/.venvs/gwift-venv/bin/activate

# MS Windows, avec Cmder
~/.venvs/gwift-venv/Scripts/activate.bat

# Pour les deux
(gwift-env) fred@aerys:~/Sources/.venvs/gwift-env$ <1>
----
<1> Le terminal signale que nous sommes bien dans l'environnement `gwift-env`.

A prÃ©sent que l'environnement est activÃ©, tous les binaires de cet environnement prendront le pas sur les binaires du systÃ¨me.
De la mÃªme maniÃ¨re, une variable `PATH` propre est dÃ©finie et utilisÃ©e, afin que les librairies Python y soient stockÃ©es.
C'est donc dans cet environnement virtuel que nous retrouverons le code source de Django, ainsi que des librairies externes pour Python une fois que nous les aurons installÃ©es.

NOTE: Pour les curieux, un environnement virtuel n'est jamais qu'un rÃ©pertoire dans lequel se trouve une installation fraÃ®che de l'interprÃ©teur, vers laquelle pointe les liens symboliques des binaires. Si vous recherchez l'emplacement de l'interprÃ©teur avec la commande `which python`, vous recevrez comme rÃ©ponse `/home/fred/.venvs/gwift-env/bin/python`.

Pour sortir de l'environnement virtuel, exÃ©cutez la commande `deactivate`.
Si vous pensez ne plus en avoir besoin, supprimer le dossier.
Si nÃ©cessaire, il suffira d'en crÃ©er un nouveau.

Pour gÃ©rer des versions diffÃ©rentes d'une mÃªme librairie, il nous suffit de jongler avec autant d'environnements que nÃ©cessaires. Une application nÃ©cessite une version de Django infÃ©rieure Ã  la 2.0 ? On crÃ©e un environnement, on l'active et on installe ce qu'il faut.

Cette technique fonctionnera autant pour un poste de dÃ©veloppement que sur les serveurs destinÃ©s Ã  recevoir notre application.

NOTE: Par la suite, nous considÃ©rerons que l'environnement virtuel est toujours activÃ©, mÃªme si `gwift-env` n'est pas indiquÃ©.


==== Gestion des dÃ©pendances, installation de Django et crÃ©ation d'un nouveau projet

Comme nous en avons dÃ©jÃ  discutÃ©, PIP est la solution que nous avons choisie pour la gestion de nos dÃ©pendances.
Pour installer une nouvelle librairie, vous pouvez simplement passer par la commande `pip install <my_awesome_library>`.
Dans le cas de Django, et aprÃ¨s avoir activÃ© l'environnement, nous pouvons Ã  prÃ©sent y installer Django.
Comme expliquÃ© ci-dessus, la librairie restera indÃ©pendante du reste du systÃ¨me, et ne polluera aucun autre projet. nous exÃ©cuterons donc la commande suivante:

[source,bash]
----
$ source ~/.venvs/gwift-env/bin/activate # ou ~/.venvs/gwift-env/Scrips/activate.bat pour Windows.
$ pip install django
Collecting django
    Downloading Django-3.1.4
100% |################################|
Installing collected packages: django
Successfully installed django-3.1.4
----

IMPORTANT: Ici, la commande `pip install django` rÃ©cupÃ¨re la *derniÃ¨re version connue disponible dans les dÃ©pÃ´ts https://pypi.org/* (sauf si vous en avez dÃ©finis d'autres. Mais c'est hors sujet).
Nous en avons dÃ©jÃ  discutÃ©: il est important de bien spÃ©cifier la version que vous souhaitez utiliser, sans quoi vous risquez de rencontrer des effets de bord.

L'installation de Django a ajoutÃ© un nouvel exÃ©cutable: `django-admin`, que l'on peut utiliser pour crÃ©er notre nouvel espace de travail.
Par la suite, nous utiliserons `manage.py`, qui constitue un *wrapper* autour de `django-admin`.

Pour dÃ©marrer notre projet, nous lanÃ§ons `django-admin startproject gwift`:

[source,bash]
----
$ django-admin startproject gwift
----

Cette action a pour effet de crÃ©er un nouveau dossier `gwift`, dans lequel nous trouvons la structure suivante:

[source,bash]
----
$ tree gwift
gwift
â”œâ”€â”€ gwift
|   |â”€â”€ asgi.py
â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”œâ”€â”€ settings.py
â”‚Â Â  â”œâ”€â”€ urls.py
â”‚Â Â  â””â”€â”€ wsgi.py
â””â”€â”€ manage.py
----


C'est dans ce rÃ©pertoire que vont vivre tous les fichiers liÃ©s au projet. Le but est de faire en sorte que toutes les opÃ©rations (maintenance, dÃ©ploiement, Ã©criture, tests, ...) puissent se faire Ã  partir d'un seul point d'entrÃ©e.

L'utilitÃ© de ces fichiers est dÃ©finie ci-dessous:

 * `settings.py` contient tous les paramÃ¨tres globaux Ã  notre projet.
 * `urls.py` contient les variables de routes, les adresses utilisÃ©es et les fonctions vers lesquelles elles pointent.
 * `manage.py`, pour toutes les commandes de gestion.
 * `asgi.py` contient la dÃ©finition de l'interface https://en.wikipedia.org/wiki/Asynchronous_Server_Gateway_Interface[ASGI], le protocole pour la passerelle asynchrone entre votre application et le serveur Web.
 * `wsgi.py` contient la dÃ©finition de l'interface https://en.wikipedia.org/wiki/Web_Server_Gateway_Interface[WSGI], qui permettra Ã  votre serveur Web (Nginx, Apache, ...) de faire un pont vers votre projet.

NOTE: Indiquer qu'il est possible d'avoir plusieurs structures de dossiers et qu'il n'y a pas de "magie" derriÃ¨re toutes ces commandes.

Tant que nous y sommes, nous pouvons ajouter un rÃ©pertoire dans lequel nous stockerons les dÃ©pendances et un fichier README:

[source,bash]
----
(gwift) $ mkdir requirements
(gwift) $ touch README.md
(gwift) $ tree gwift
gwift
â”œâ”€â”€ gwift
â”‚Â Â  â”œâ”€â”€ asgi.py
â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”œâ”€â”€ settings.py
â”‚Â Â  â”œâ”€â”€ urls.py
â”‚Â Â  â””â”€â”€ wsgi.py
â”œâ”€â”€ requirements <1>
â”œâ”€â”€ README.md <2>
â””â”€â”€ manage.py
----
<1> Ici
<2> Et lÃ 



Comme nous venons d'ajouter une dÃ©pendance Ã  notre projet, profitons-en pour crÃ©er un fichier reprenant tous les dÃ©pendances de notre projet.
Celles-ci sont normalement placÃ©es dans un fichier `requirements.txt`.
Dans un premier temps, ce fichier peut Ãªtre placÃ© directement Ã  la racine du projet, mais on prÃ©fÃ©rera rapidement le dÃ©placer dans un sous-rÃ©pertoire spÃ©cifique (`requirements`), afin de grouper les dÃ©pendances en fonction de leur environnement de destination:

 * `base.txt`
 * `dev.txt`
 * `production.txt`

Au dÃ©but de chaque fichier, il suffit d'ajouter la ligne `-r base.txt`, puis de lancer l'installation grÃ¢ce Ã  un `pip install -r <nom du fichier>`.
De cette maniÃ¨re, il est tout Ã  fait acceptable de n'installer `flake8` et `django-debug-toolbar` qu'en dÃ©veloppement par exemple.
Dans l'immÃ©diat, nous allons ajouter `django` dans une version strictement infÃ©rieure Ã  la version 3.2 dans le fichier `requirements/base.txt`.

[source,bash]
----
$ echo 'django<3.2' > requirements/base.txt
$ echo '-r base.txt' > requirements/prod.txt
$ echo '-r base.txt' > requirements/dev.txt
----

IMPORTANT: Prenez directement l'habitude de spÃ©cifier la version ou les versions compatibles: les librairies que vous utilisez comme dÃ©pendances Ã©voluent, de la mÃªme maniÃ¨re que vos projets.
Pour Ãªtre sÃ»r et certain le code que vous avez Ã©crit continue Ã  fonctionner, spÃ©cifiez la version de chaque librairie de dÃ©pendances.
Entre deux versions d'une mÃªme librairie, des fonctions sont cassÃ©es, certaines signatures sont modifiÃ©es, des comportements sont altÃ©rÃ©s, etc. Il suffit de parcourir les pages de _Changements incompatibles avec les anciennes versions dans Django_ https://docs.djangoproject.com/fr/3.1/releases/3.0/[(par exemple ici pour le passage de la 3.0 Ã  la 3.1)] pour rÃ©aliser que certaines opÃ©rations ne sont pas anodines, et que sans filet de sÃ©curitÃ©, c'est le mur assurÃ©.
Avec les mÃ©canismes d'intÃ©gration continue et de tests unitaires, nous verrons plus loin comment se prÃ©munir d'un changement inattendu.


=== Django

Comme nous l'avons vu ci-dessus, `django-admin` permet de crÃ©er un nouveau projet.
Nous faisons ici une distinction entre un **projet** et une **application**:

 * *Un projet* reprÃ©sente l'ensemble des applications, paramÃ¨tres, pages HTML, middlewares, dÃ©pendances, etc., qui font que votre code fait ce qu'il est sensÃ© faire.
 * *Une application* est un contexte d'exÃ©cution, idÃ©alement autonome, d'une partie du projet.

Pour `gwift`, nous aurons:

.Django Projet vs Applications
image::images/django/django-project-vs-apps-gwift.png[]

. une premiÃ¨re application pour la gestion des listes de souhaits et des Ã©lÃ©ments,
. une deuxiÃ¨me application pour la gestion des utilisateurs,
. voire une troisiÃ¨me application qui gÃ©rera les partages entre utilisateurs et listes.

Nous voyons Ã©galement que la gestion des listes de souhaits et Ã©lÃ©ments aura besoin de la gestion des utilisateurs - elle n'est pas autonome -, tandis que la gestion des utilisateurs n'a aucune autre dÃ©pendance qu'elle-mÃªme.

Pour `khana`, nous pourrions avoir quelque chose comme ceci:

.Django Project vs Applications
image::images/django/django-project-vs-apps-khana.png[]

En rouge, vous pouvez voir quelque chose que nous avons dÃ©jÃ  vu: la gestion des utilisateurs et la possibilitÃ© qu'ils auront de communiquer entre eux.
Ceci pourrait Ãªtre commun aux deux applications.
Nous pouvons clairement visualiser le principe de **contexte** pour une application: celle-ci viendra avec son modÃ¨le, ses tests, ses vues et son paramÃ©trage et pourrait ainsi Ãªtre rÃ©utilisÃ©e dans un autre projet.
C'est en Ã§a que consistent les https://www.djangopackages.com/[paquets Django] dÃ©jÃ  disponibles: ce sont "_simplement_" de petites applications empaquetÃ©es et pouvant Ãªtre rÃ©utilisÃ©es dans diffÃ©rents contextes (eg. https://github.com/tomchristie/django-rest-framework[Django-Rest-Framework], https://github.com/django-debug-toolbar/django-debug-toolbar[Django-Debug-Toolbar], ...).


==== manage.py

Le fichier `manage.py` que vous trouvez Ã  la racine de votre projet est un *wrapper* sur les commandes `django-admin`.
A partir de maintenant, nous n'utiliserons plus que celui-lÃ  pour tout ce qui touchera Ã  la gestion de notre projet:

 * `manage.py check` pour vÃ©rifier (en surface...) que votre projet ne rencontre aucune erreur Ã©vidente
 * `manage.py check --deploy`, pour vÃ©rifier (en surface aussi) que l'application est prÃªte pour un dÃ©ploiement
 * `manage.py runserver` pour lancer un serveur de dÃ©veloppement
 * `manage.py test` pour dÃ©couvrir les tests unitaires disponibles et les lancer.

La liste complÃ¨te peut Ãªtre affichÃ©e avec `manage.py help`.
Vous remarquerez que ces commandes sont groupÃ©es selon diffÃ©rentes catÃ©gories:

 * **auth**: crÃ©ation d'un nouveau super-utilisateur, changer le mot de passe pour un utilisateur existant.
 * **django**: vÃ©rifier la *compliance* du projet, lancer un *shell*, *dumper* les donnÃ©es de la base, effectuer une migration du schÃ©ma, ...
 * **sessions**: suppressions des sessions en cours
 * **staticfiles**: gestion des fichiers statiques et lancement du serveur de dÃ©veloppement.

Nous verrons plus tard comment ajouter de nouvelles commandes.

Si nous dÃ©marrons la commande `python manage.py runserver`, nous verrons la sortie console suivante:

[source,bash]
----
$ python manage.py runserver
Watching for file changes with StatReloader
Performing system checks...

System check identified no issues (0 silenced).

[...]

December 15, 2020 - 20:45:07
Django version 3.1.4, using settings 'gwift.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CTRL-BREAK.
----

Si nous nous rendons sur la page http://127.0.0.1:8000 (ou http://localhost:8000) comme le propose si gentiment notre (nouveau) meilleur ami, nous verrons ceci:

.python manage.py runserver (Non, ce n'est pas Challenger)
image::images/django/manage-runserver.png[]

IMPORTANT: Nous avons mis un morceau de la sortie console entre crochet `[...]` ci-dessus, car elle concerne les migrations.
Si vous avez suivi les Ã©tapes jusqu'ici, vous avez Ã©galement dÃ» voir un message type `You have 18 unapplied migration(s). [...] Run 'python manage.py migrate' to apply them.`
Cela concerne les migrations, et c'est un point que nous verrons un peu plus tard.


==== CrÃ©ation d'une nouvelle application

Maintenant que nous avons a vu Ã  quoi servait `manage.py`, nous pouvons crÃ©er notre nouvelle application grÃ¢ce Ã  la commande `manage.py startapp <label>`.

Notre premiÃ¨re application servira Ã  structurer les listes de souhaits, les Ã©lÃ©ments qui les composent et les parties que chaque utilisateur pourra offrir.
De maniÃ¨re gÃ©nÃ©rale, essayez de trouver un nom Ã©loquent, court et qui rÃ©sume bien ce que fait l'application.
Pour nous, ce sera donc `wish`.

C'est parti pour `manage.py startapp wish`!

[source,bash]
----
$ python manage.py startapp wish
----

RÃ©sultat? Django nous a crÃ©Ã© un rÃ©pertoire `wish`, dans lequel nous trouvons les fichiers et dossiers suivants:

 * `wish/__init__.py` pour que notre rÃ©pertoire `wish` soit converti en package Python.
 * `wish/admin.py` servira Ã  structurer l'administration de notre application. Chaque information peut Ãªtre administrÃ©e facilement au travers d'une interface gÃ©nÃ©rÃ©e Ã  la volÃ©e par le framework. Nous y reviendrons par la suite.
 * `wish/migrations/` est le dossier dans lequel seront stockÃ©es toutes les diffÃ©rentes migrations de notre application (= toutes les modifications que nous apporterons aux donnÃ©es que nous souhaiterons manipuler)
 * `wish/models.py` reprÃ©sentera et structurera nos donnÃ©es, et est intimement liÃ© aux migrations.
 * `wish/tests.py` pour les tests unitaires.

NOTE: Par soucis de clartÃ©, vous pouvez dÃ©placer ce nouveau rÃ©pertoire `wish` dans votre rÃ©pertoire `gwift` existant.
C'est une forme de convention.

La structure de vos rÃ©pertoires devient celle-ci:

[source,bash]
----
(gwift-env) fred@aerys:~/Sources/gwift$ tree .
.
â”œâ”€â”€ gwift
â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”œâ”€â”€ asgi.py
â”‚Â Â  â”œâ”€â”€ settings.py
â”‚Â Â  â”œâ”€â”€ urls.py
â”‚Â Â  â”œâ”€â”€ wish <1>
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ admin.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ apps.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ migrations
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ __init__.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ models.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ tests.py
â”‚Â Â  â”‚Â Â  â””â”€â”€ views.py
â”‚Â Â  â””â”€â”€ wsgi.py
â”œâ”€â”€ Makefile
â”œâ”€â”€ manage.py
â”œâ”€â”€ README.md
â”œâ”€â”€ requirements
â”‚Â Â  â”œâ”€â”€ base.txt
â”‚Â Â  â”œâ”€â”€ dev.txt
â”‚Â Â  â””â”€â”€ prod.txt
â”œâ”€â”€ setup.cfg
â””â”€â”€ tox.ini

5 directories, 22 files
----
<1> Notre application a bien Ã©tÃ© crÃ©Ã©e, et nous l'avons dÃ©placÃ©e dans le rÃ©pertoire `gwift` !



==== Fonctionement gÃ©nÃ©ral

Le mÃ©tier de programmeur est devenu de plus en plus complexe. Il y a 20 ans, nous pouvions nous contenter d'une simple page PHP dans laquelle nous mixions l'ensemble des actios Ã  rÃ©aliser: requÃªtes en bases de donnÃ©es, construction de la page, ... 
La recherche d'une solution a un problÃ¨me n'Ã©tait pas spÃ©cialement plus complexe - dans la mesure oÃ¹ le rendu des enregistrements en direct n'Ã©tait finalement qu'une forme un chouia plus Ã©voluÃ©e du `print()` ou des `System.out.println()` - mais c'Ã©tait l'Ã©volutivitÃ© des applications qui en prenait un coup: une grosse partie des tÃ¢ches Ã©taient dupliquÃ©es entre les diffÃ©rentes pages, et l'ajout d'une nouvelle fonctionnalitÃ© Ã©tait relativement ardue.

Django (et d'autres cadriciels) rÃ©solvent ce problÃ¨me en se basant ouvertement sur le principe de `Don't repeat yourself` footnote:[DRY].
Chaque morceau de code ne doit apparaitre qu'une seule fois, afin de limiter au maximum la redite (et donc, l'application d'un mÃªme correctif Ã  diffÃ©rents endroits).

Le chemin parcouru par une requÃªte est expliquÃ© en (petits) dÃ©tails ci-dessous.

.How it works
image::images/diagrams/django-how-it-works.png[]

*1. Un utilisateur ou un visiteur souhaite accÃ©der Ã  une URL hÃ©bergÃ©e et servie par notre application*. 
Ici, nous prenons l'exemple de l'URL fictive `https://gwift/wishes/91827`.
Lorsque cette URL "arrive" dans notre application, son point d'entrÃ©e se trouvera au niveau des fichiers `asgi.py` ou `wsgi.py`. Nous verrons cette partie plus tard, et nous pouvons nous concentrer sur le chemin interne qu'elle va parcourir.

*Etape 0* - La premiÃ¨re Ã©tape consiste Ã  vÃ©rifier que cette URL rÃ©pond Ã  un schÃ©ma que nous avons dÃ©fini dans le fichier `gwift/urls.py`. 

*Etape 1* - Si ce n'est pas le cas, l'application n'ira pas plus loin et retournera une erreur Ã  l'utilisateur.


*Etape 2* - Django va parcourir l'ensemble des _patterns_ prÃ©sents dans le fichier `urls.py` et s'arrÃªtera sur le premier qui correspondra Ã  la requÃªte qu'il a reÃ§ue. 
Ce cas est relativement trivial: la requÃªte `/wishes/91827` a une correspondance au niveau de la ligne `path("wishes/<int:wish_id>` dans l'exemple ci-dessous. 
Django va alors appeler la fonction footnote:[Qui ne sera pas toujours une fonction. Django s'attend Ã  trouver un _callable_, c'est-Ã -dire n'importe quel Ã©lÃ©ment qu'il peut appeler comme une fonction.] associÃ©e Ã  ce _pattern_, c'est-Ã -dire `wish_details` du module `gwift.views`.

[source,python]
----
from django.contrib import admin
from django.urls import path

from gwift.views import wish_details <1>

urlpatterns = [
    path('admin/', admin.site.urls),
    path("wishes/<int:wish_id>", wish_details), <2>
]
----
<1> Nous importons la fonction `wish_details` du module `gwift.views`
<2> Champomy et cotillons! Nous avons une correspondance avec `wishes/details/91827`


TODO: En fait, il faudrait quand mÃªme s'occuper du modÃ¨le ici. 
TODO: et de la mise en place de l'administration, parce que nous en aurons besoin pour les Ã©tapes de dÃ©ploiement.

[line-through]#Nous n'allons pas nous occuper de l'accÃ¨s Ã  la base de donnÃ©es pour le moment (nous nous en occuperons dans un prochain chapitre) et nous nous contenterons de remplir un canevas avec un ensemble de donnÃ©es.#

Le module `gwift.views` qui se trouve dans le fichier `gwift/views.py` peut ressembler Ã  ceci:

[source,python]
----
[...]

from datetime import datetime


def wishes_details(request: HttpRequest, wish_id: int) -> HttpResponse:
    context = {
        "user_name": "Bond,"
        "user_first_name": "James",
        "now": datetime.now()
    }

    return render(
        request,
        "wish_details.html",
        context
    )
----

Pour rÃ©sumer, cette fonction permet:

. De construire un _contexte_, qui est reprÃ©sentÃ© sous la forme d'un dictionnaire associant des clÃ©s Ã  des valeurs. Les clÃ©s sont respectivement `user_name`, `user_first_name` et `now`, tandis que leurs valeurs respectives sont `Bond`, `James` et le `moment prÃ©sent` footnote:[Non, pas celui d'Eckhart Tolle].
. Nous passons ensuite ce dictionnaire Ã  un canevas, `wish_details.html`
. L'application du contexte sur le canevas nous donne un rÃ©sultat.

[source,html]
----
<!-- fichier wish_details.html -->
<!DOCTYPE html>
<html>
<head>
  <title>Page title</title>
</head>
<body>
  <h1>ğŸ‘¤ Hi!</h1>
  <p>My name is {{ user_name }}. {{ user_first_name }} {{ user_name }}.</p>
  <p>This page was generated at {{ now }}</p>
</body>
</html>
----

AprÃ¨s application de notre contexte sur ce template, nous obtiendrons ce document, qui sera renvoyÃ© au navigateur de l'utilisateur qui aura fait la requÃªte initiale:

[source,html]
----
<!DOCTYPE html>
<html>
<head>
  <title>Page title</title>
</head>
<body>
  <h1>ğŸ‘¤ Hi!</h1>
  <p>My name is Bond. James Bond.</p>
  <p>This page was generated at 2027-03-19 19:47:38</p>
</body>
</html>
----

.RÃ©sultat
image::images/django/django-first-template.png[]

==== 12 facteurs et configuration globale

-> Faire le lien avec les settings
-> Faire le lien avec les douze facteurs
-> Construction du fichier setup.cfg


==== setup.cfg

(Repris de cookie-cutter-django)

[source,ini]
----
[flake8]
max-line-length = 120
exclude = .tox,.git,*/migrations/*,*/static/CACHE/*,docs,node_modules,venv

[pycodestyle]
max-line-length = 120
exclude = .tox,.git,*/migrations/*,*/static/CACHE/*,docs,node_modules,venv

[mypy]
python_version = 3.8
check_untyped_defs = True
ignore_missing_imports = True
warn_unused_ignores = True
warn_redundant_casts = True
warn_unused_configs = True
plugins = mypy_django_plugin.main

[mypy.plugins.django-stubs]
django_settings_module = config.settings.test

[mypy-*.migrations.*]
# Django migrations should not produce any errors:
ignore_errors = True

[coverage:run]
include = khana/*
omit = *migrations*, *tests*
plugins =
    django_coverage_plugin

----


=== Structure finale de notre environnement

Nous avons donc la strucutre finale pour notre environnement de travail:

[source,bash]
----
(gwift-env) fred@aerys:~/Sources/gwift$ tree .
.
â”œâ”€â”€ gwift
â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”œâ”€â”€ asgi.py
â”‚Â Â  â”œâ”€â”€ settings.py
â”‚Â Â  â”œâ”€â”€ urls.py
â”‚Â Â  â”œâ”€â”€ wish <1>
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ admin.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ apps.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ migrations
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ __init__.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ models.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ tests.py
â”‚Â Â  â”‚Â Â  â””â”€â”€ views.py
â”‚Â Â  â””â”€â”€ wsgi.py
â”œâ”€â”€ Makefile
â”œâ”€â”€ manage.py
â”œâ”€â”€ README.md
â”œâ”€â”€ requirements
â”‚Â Â  â”œâ”€â”€ base.txt
â”‚Â Â  â”œâ”€â”€ dev.txt
â”‚Â Â  â””â”€â”€ prod.txt
â”œâ”€â”€ setup.cfg
â””â”€â”€ tox.ini
----

=== Cookie cutter

Pfiou! Ca en fait des commandes et du boulot pour "juste" dÃ©marrer un nouveau projet, non? Sachant qu'en plus, nous avons dÃ» modifier des fichiers, dÃ©placer des dossiers, ajouter des dÃ©pendances, configurer une base de donnÃ©es, ... 

Bonne nouvelle! Il existe des gÃ©nÃ©rateurs, permettant de dÃ©marrer rapidement un nouveau projet sans (trop) se prendre la tÃªte. Le plus connu (et le plus personnalisable) est https://cookiecutter.readthedocs.io/[Cookie-Cutter], qui se base sur des canevas _type https://pypi.org/project/Jinja2/[Jinja2]_, pour crÃ©er une arborescence de dossiers et fichiers conformes Ã  votre maniÃ¨re de travailler. Et si vous avez la flemme de crÃ©er votre propre canevas, vous pouvez utiliser https://cookiecutter-django.readthedocs.io[ceux qui existent dÃ©jÃ ].

Pour dÃ©marrer, crÃ©ez un environnement virtuel (comme d'habitude):

[source,bash]
----
Î» python -m venv .venvs\cookie-cutter-khana
Î» .venvs\cookie-cutter-khana\Scripts\activate.bat
(cookie-cutter-khana) Î» pip install cookiecutter

  Collecting cookiecutter
  [...]
  Successfully installed Jinja2-2.11.2 MarkupSafe-1.1.1 arrow-0.17.0 binaryornot-0.4.4 certifi-2020.12.5 chardet-4.0.0 click-7.1.2 cookiecutter-1.7.2 idna-2.10 jinja2-time-0.2.0 poyo-0.5.0 python-dateutil-2.8.1 python-slugify-4.0.1 requests-2.25.1 six-1.15.0 text-unidecode-1.3 urllib3-1.26.2

(cookie-cutter-khana) Î» cookiecutter https://github.com/pydanny/cookiecutter-django

  [...]

 [SUCCESS]: Project initialized, keep up the good work!
----

Si vous explorez les diffÃ©rents fichiers, vous trouverez beaucoup de similitudes avec la configuration que nous vous proposions ci-dessus. 
En fonction de votre expÃ©rience, vous serez tentÃ© de modifier certains paramÃ¨tres, pour faire correspondre ces sources avec votre utilisation ou vos habitudes.

NOTE: Il est aussi possible d'utiliser l'argument `--template`, suivie d'un argument reprenant le nom de votre projet (`<my_project>`), lors de l'initialisation d'un projet avec la commande `startproject` de `django-admin`, afin de calquer votre arborescence sur un projet existant. 
La https://docs.djangoproject.com/en/stable/ref/django-admin/#startproject[documentation] Ã  ce sujet est assez complÃ¨te.

[source,bash]
----
django-admin.py startproject --template=https://[...].zip <my_project>
----